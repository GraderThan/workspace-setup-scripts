#!/usr/bin/env python3
"""
run-c: compile and run C projects.

Defaults:
  - Compiler: clang (falls back to $CC, then gcc, then cc)
  - C standard: C11
  - Build dir: /tmp/graderthan/ide/c/build
  - Output: app.bin

Behavior:
  - If you pass one or more source FILES or DIRS, this (by default) also adds all sibling
    *.c in each provided path's directory AND its subdirectories (recursive).
    Use --no-siblings to restrict to exactly what you passed.
    Use --no-recursive to include only the top-level directory.
  - If you pass no sources, it compiles *.c from the CURRENT directory (recursive by default).
  - Custom build template (-c/--build-cmd) must include %SOURCES% and %OUTPUT%.

Examples:
  run-c /path/to/cli.c                   # compiles all *.c under /path/to (recursive)
  run-c --no-recursive /path/to/cli.c    # compiles all *.c beside cli.c (no subdirs)
  run-c --no-siblings /path/to/cli.c     # compiles only cli.c
  run-c /path/to/project/                # compiles all *.c under that dir (recursive)
  run-c                                   # compiles *.c under cwd (recursive)
  run-c -c "clang -O2 %SOURCES% -o %OUTPUT%"
"""

import argparse
import glob
import os
import shlex
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Iterable, List, Optional, Set

DEFAULT_BUILD_DIR = "/tmp/graderthan/ide/c/build"
DEFAULT_OUTPUT_NAME = "app.bin"
DEFAULT_COMPILER = "clang"
DEFAULT_BUILD_CMD_TEMPLATE = (
    "%SOURCES% -g -std=c11 -Wall -Wextra -Wpedantic "
    "-Werror=implicit-function-declaration "
    "-Werror=incompatible-pointer-types "
    "-Werror=int-conversion "
    "-Werror=return-type "
    "-Werror=format -o"
)


def which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


def pick_c_compiler(preferred: Optional[str]) -> str:
    if preferred and which(preferred):
        return preferred
    cc = os.environ.get("CC")
    if cc and which(cc):
        return cc
    for cand in ("clang", "gcc", "cc"):
        if which(cand):
            return cand
    for base, rng in (("clang-", range(30, 9, -1)), ("gcc-", range(20, 9, -1))):
        for v in rng:
            cand = f"{base}{v}"
            if which(cand):
                return cand
    sys.stderr.write(
        "No suitable C compiler found (tried --compiler, $CC, clang, gcc, cc, and versioned variants).\n"
    )
    sys.exit(1)


def collect_c_files_from_dir(root: Path, recursive: bool) -> Iterable[Path]:
    if recursive:
        return (p for p in root.rglob("*.c") if p.is_file())
    else:
        return (p for p in root.glob("*.c") if p.is_file())


def normalize_sources(argv_paths: List[str], include_siblings: bool, recursive: bool) -> List[Path]:
    """
    If user provided paths:
      - Resolve them (files or directories).
      - Start with explicitly provided files.
      - If include_siblings: for each provided file/dir, add *.c from that dir (and subdirs if recursive).
    If none provided:
      - Compile *.c from cwd (recursive by default).
    """
    result: Set[Path] = set()

    if argv_paths:
        given_paths = [Path(s).resolve() for s in argv_paths]

        # Add explicit files only (keep exactly what was specified)
        for p in given_paths:
            if p.is_file() and p.suffix == ".c":
                result.add(p)

        if include_siblings:
            dirs: Set[Path] = set()
            for p in given_paths:
                if p.is_dir():
                    dirs.add(p)
                else:
                    dirs.add(p.parent)

            for d in dirs:
                for f in collect_c_files_from_dir(d, recursive=recursive):
                    result.add(f)
    else:
        # No args: collect from cwd
        cwd = Path(".").resolve()
        for f in collect_c_files_from_dir(cwd, recursive=recursive):
            result.add(f)

    return sorted(result)


def build_command(compiler: str, sources: List[Path], output_path: Path, custom_template: Optional[str]) -> str:
    sources_str = " ".join(shlex.quote(str(s)) for s in sources)

    if custom_template:
        cmd = custom_template.replace("%OUTPUT%", shlex.quote(str(output_path)))
        cmd = cmd.replace("%SOURCES%", sources_str)
        return cmd

    template = DEFAULT_BUILD_CMD_TEMPLATE.replace("%SOURCES%", sources_str)
    parts = [shlex.quote(compiler), template, shlex.quote(str(output_path))]
    return " ".join(parts)


def main() -> int:
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("-d", "--build-dir", default=DEFAULT_BUILD_DIR)
    parser.add_argument("-c", "--build-cmd", default=None,
                        help="Full build command template with %OUTPUT% and %SOURCES% placeholders.")
    parser.add_argument("-o", "--output", default=None)
    parser.add_argument("-C", "--compiler", default=None)
    parser.add_argument("--no-siblings", action="store_true",
                        help="Do NOT auto-include sibling *.c files next to provided paths.")
    parser.add_argument("--no-recursive", action="store_true",
                        help="When including siblings or scanning dirs, do NOT recurse into subdirectories.")
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-h", "--help", action="store_true")
    parser.add_argument("paths", nargs="*",
                        help="Source files or directories to compile.")
    args = parser.parse_args()

    if args.help:
        print(__doc__)
        return 0

    recursive = not args.no_recursive
    sources = normalize_sources(args.paths, include_siblings=not args.no_siblings, recursive=recursive)

    if not sources:
        sys.stderr.write("No C sources found.\n")
        return 1

    if args.verbose:
        print("Sources:")
        for p in sources:
            print(f"  {p}")

    compiler = pick_c_compiler(args.compiler)
    if args.verbose:
        print(f"Using compiler: {compiler}")

    build_dir = Path(args.build_dir).resolve()
    output_name = args.output or DEFAULT_OUTPUT_NAME
    output_path = build_dir / output_name

    if args.verbose:
        print(f"Ensuring build directory exists: {build_dir}")
    build_dir.mkdir(parents=True, exist_ok=True)

    if output_path.exists():
        if args.verbose:
            print(f"Removing existing executable: {output_path}")
        try:
            output_path.unlink()
        except OSError as e:
            sys.stderr.write(f"Failed to remove existing output: {e}\n")
            return 1

    cmd = build_command(compiler, sources, output_path, args.build_cmd)
    if args.verbose:
        print("Build command:")
        print(f"  {cmd}")
        print("Compiling...")

    if args.verbose:
        proc = subprocess.run(cmd, shell=True)
        rc = proc.returncode
        if rc != 0:
            print("Compilation failed.", file=sys.stderr)
            return rc or 1
    else:
        proc = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        rc = proc.returncode
        if rc != 0:
            print("Compilation failed.", file=sys.stderr)
            print("Compiler output:", file=sys.stderr)
            if proc.stdout:
                sys.stderr.write(proc.stdout)
            if proc.stderr:
                sys.stderr.write(proc.stderr)
            return rc or 1

    if args.verbose:
        print(f"Running {output_path}...")
    try:
        run = subprocess.run([str(output_path)])
        return run.returncode
    except OSError as e:
        sys.stderr.write(f"Failed to run {output_path}: {e}\n")
        return 1


if __name__ == "__main__":
    sys.exit(main())
