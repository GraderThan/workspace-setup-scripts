#!/usr/bin/env python3
"""
run-cpp: compile and run C++ projects.

Defaults:
  - Compiler: clang++ (falls back to $CXX, then g++, then versioned variants)
  - C++ standard: C++20
  - Build dir: /tmp/graderthan/ide/cpp/build
  - Output: app.bin

Behavior:
  - If you pass one or more source FILES or DIRS, this (by default) also adds all sibling
    *.cpp in each provided path's directory AND its subdirectories (recursive).
    Use --no-siblings to restrict to exactly what you passed.
    Use --no-recursive to include only the top-level directory.
  - If you pass no sources, it compiles *.cpp from the CURRENT directory (recursive by default).
  - Custom build template (-c/--build-cmd) must include %SOURCES% and %OUTPUT%.
  - Smart modules flag: adds -fmodules-ts only if sources look modular AND the compiler supports it.

Examples:
  run-cpp /path/to/cli.cpp                  # compiles all *.cpp under /path/to (recursive)
  run-cpp --no-recursive /path/to/cli.cpp   # compiles all *.cpp beside cli.cpp (no subdirs)
  run-cpp --no-siblings /path/to/cli.cpp    # compiles only cli.cpp
  run-cpp /path/to/project/                 # compiles all *.cpp under that dir (recursive)
  run-cpp                                    # compiles *.cpp under cwd (recursive)
  run-cpp -c "clang++ -O2 %SOURCES% -o %OUTPUT%"
"""

import argparse
import glob
import os
import re
import shlex
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Iterable, List, Optional, Set

DEFAULT_BUILD_DIR = "/tmp/graderthan/ide/cpp/build"
DEFAULT_OUTPUT_NAME = "app.bin"
DEFAULT_COMPILER = "clang++"
DEFAULT_BUILD_CMD_TEMPLATE = (
    "%SOURCES% -g -std=c++20 "
    "-Werror=uninitialized -Werror=nonnull -Werror=format "
    "-Werror=bool-compare -Werror=return-type -Werror=array-bounds -o"
)

MODULES_TOKEN_RE = re.compile(r'(^|\W)(module|import)\b', re.MULTILINE)


def which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


def pick_cxx_compiler(preferred: Optional[str]) -> str:
    if preferred and which(preferred):
        return preferred
    cxx = os.environ.get("CXX")
    if cxx and which(cxx):
        return cxx
    for cand in ("clang++", "g++"):
        if which(cand):
            return cand
    for base, vers in (("clang++-", range(30, 9, -1)), ("g++-", range(20, 9, -1))):
        for v in vers:
            cand = f"{base}{v}"
            if which(cand):
                return cand
    sys.stderr.write("No suitable C++ compiler found (tried --compiler, $CXX, clang++, g++, versioned variants).\n")
    sys.exit(1)


def collect_cpp_files_from_dir(root: Path, recursive: bool) -> Iterable[Path]:
    if recursive:
        return (p for p in root.rglob("*.cpp") if p.is_file())
    else:
        return (p for p in root.glob("*.cpp") if p.is_file())


def normalize_sources(argv_paths: List[str], include_siblings: bool, recursive: bool) -> List[Path]:
    """
    If user provided paths:
      - Resolve them (files or directories).
      - Start with explicitly provided files.
      - If include_siblings: for each provided file/dir, add *.cpp from that dir (and subdirs if recursive).
    If none provided:
      - Compile *.cpp from cwd (recursive by default).
    """
    result: Set[Path] = set()

    if argv_paths:
        given_paths = [Path(s).resolve() for s in argv_paths]

        for p in given_paths:
            if p.is_file() and p.suffix == ".cpp":
                result.add(p)

        if include_siblings:
            dirs: Set[Path] = set()
            for p in given_paths:
                if p.is_dir():
                    dirs.add(p)
                else:
                    dirs.add(p.parent)

            for d in dirs:
                for f in collect_cpp_files_from_dir(d, recursive=recursive):
                    result.add(f)
    else:
        cwd = Path(".").resolve()
        for f in collect_cpp_files_from_dir(cwd, recursive=recursive):
            result.add(f)

    return sorted(result)


def sources_use_modules(paths: List[Path]) -> bool:
    for p in paths:
        try:
            with open(p, "r", encoding="utf-8", errors="ignore") as f:
                text = f.read(8192)
            if MODULES_TOKEN_RE.search(text):
                return True
        except OSError:
            continue
    return False


def compiler_supports_flag(compiler: str, flag: str) -> bool:
    try:
        proc = subprocess.run(
            [compiler, "-x", "c++", "-std=c++20", flag, "-", "-o", os.devnull],
            input=b"int main(){return 0;}\n",
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        return proc.returncode == 0
    except OSError:
        return False


def build_command(compiler: str, sources: List[Path], output_path: Path,
                  custom: Optional[str], add_modules_flag: bool) -> str:
    srcs = " ".join(shlex.quote(str(s)) for s in sources)
    if custom:
        cmd = custom.replace("%OUTPUT%", shlex.quote(str(output_path)))
        cmd = cmd.replace("%SOURCES%", srcs)
        return cmd
    template = DEFAULT_BUILD_CMD_TEMPLATE.replace("%SOURCES%", srcs)
    pieces = [shlex.quote(compiler)]
    if add_modules_flag:
        pieces.append("-fmodules-ts")
    pieces.append(template)
    pieces.append(shlex.quote(str(output_path)))
    return " ".join(pieces)


def main() -> int:
    parser = argparse.ArgumentParser(add_help=False)
    parser.add_argument("-d", "--build-dir", default=DEFAULT_BUILD_DIR)
    parser.add_argument("-c", "--build-cmd", default=None,
                        help="Full build command template with %OUTPUT% and %SOURCES% placeholders.")
    parser.add_argument("-o", "--output", default=None)
    parser.add_argument("-C", "--compiler", default=None)
    parser.add_argument("--no-siblings", action="store_true",
                        help="Do NOT auto-include sibling *.cpp files next to provided paths.")
    parser.add_argument("--no-recursive", action="store_true",
                        help="When including siblings or scanning dirs, do NOT recurse into subdirectories.")
    parser.add_argument("-v", "--verbose", action="store_true")
    parser.add_argument("-h", "--help", action="store_true")
    parser.add_argument("paths", nargs="*",
                        help="Source files or directories to compile.")
    args = parser.parse_args()

    if args.help:
        print(__doc__)
        return 0

    recursive = not args.no_recursive
    sources = normalize_sources(args.paths, include_siblings=not args.no_siblings, recursive=recursive)

    if not sources:
        sys.stderr.write("No C++ sources found.\n")
        return 1

    if args.verbose:
        print("Sources:")
        for p in sources:
            print(f"  {p}")

    compiler = pick_cxx_compiler(args.compiler)
    if args.verbose:
        print(f"Using compiler: {compiler}")

    build_dir = Path(args.build_dir).resolve()
    output_name = args.output or DEFAULT_OUTPUT_NAME
    output_path = build_dir / output_name

    if args.verbose:
        print(f"Ensuring build directory exists: {build_dir}")
    build_dir.mkdir(parents=True, exist_ok=True)

    if output_path.exists():
        if args.verbose:
            print(f"Removing existing executable: {output_path}")
        try:
            output_path.unlink()
        except OSError as e:
            sys.stderr.write(f"Failed to remove existing output: {e}\n")
            return 1

    add_modules_flag = False
    if args.build_cmd is None:
        if sources_use_modules(sources) and compiler_supports_flag(compiler, "-fmodules-ts"):
            add_modules_flag = True
            if args.verbose:
                print("Detected modules and compiler supports -fmodules-ts; enabling it.")
        elif args.verbose:
            print("Skipping -fmodules-ts (no modules detected or compiler doesn't support it).")

    cmd = build_command(compiler, sources, output_path, args.build_cmd, add_modules_flag)
    if args.verbose:
        print("Build command:")
        print(f"  {cmd}")
        print("Compiling...")

    if args.verbose:
        proc = subprocess.run(cmd, shell=True)
        rc = proc.returncode
        if rc != 0:
            print("Compilation failed.", file=sys.stderr)
            return rc or 1
    else:
        proc = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        rc = proc.returncode
        if rc != 0:
            print("Compilation failed.", file=sys.stderr)
            print("Compiler output:", file=sys.stderr)
            if proc.stdout:
                sys.stderr.write(proc.stdout)
            if proc.stderr:
                sys.stderr.write(proc.stderr)
            return rc or 1

    if args.verbose:
        print(f"Running {output_path}...")
    try:
        run = subprocess.run([str(output_path)])
        return run.returncode
    except OSError as e:
        sys.stderr.write(f"Failed to run {output_path}: {e}\n")
        return 1


if __name__ == "__main__":
    sys.exit(main())
